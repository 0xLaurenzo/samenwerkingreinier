/*
Assignment 10
Reinier Sanders,    s4335422
Laurens Kubat,      s4626249
*/

#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include <cassert>

using namespace std;

/*
<-- Part 1 -->
(a)
3 inputs n, m, o: integers year, day & month.
Variables that have already been computed, don't need to be computed again.
So we can just take them as constants when used by other calculations.

O(f(n,m,o))=
O(a+b+c+d+e+f+g+h+i+K+L+m+month+day)=
O((n%19)+(n/100)+(n%100)+(b/4)+(b%4)+((b+8)/25)+((b-f+1)/3)+((19*a+b-d-g+15)%30)+(c/4)+(c%4)+((32+2*e+2*i-h-k)%7)+((a+11*h+22*L)/451)+((h+L-7*m+114)/31)+((h+L-7*m+114)%31)+1)=
O(n+n+n+n+n+n+n+2*n+n+n+3*n+3*n+2*m+2*o)=
O((17*n)+(2*m)+(2*o))=
O(n+m+o)

(b)
2 inputs n, m: integers x & divisor.

We perform a calculation of

O(f(n,m))=
O(n%m)=
O(nm)

a square root of n times, so:

O(f(n,m))=
O(sqrt(n)*(nm))=

<-- Part 2 -->
(a)
array = {15, 40, 42, -15, 30, 35, 5}.

Initial tree:
       15
     /    \
   40      42
  /  \    /  \
-15  30  35   5

Phase 1:
We start at A[0]. We first check A[1]. 40 > 15, so 40 gets pushed up:
       40
     /    \
   15      42
  /  \    /  \
-15  30  35   5

Then we check A[2]. 42 > 40, so 42 gets pushed up:
       42
     /    \
   15      40
  /  \    /  \
-15  30  35   5

Then it checks A[3]. -15 < 15, so it stays. A[4] = 30, 30 > 15, so 30 gets pushed up:
       42
     /    \
   30      40
  /  \    /  \
-15  15  35   5

After that, we go to A[5], which is 35. 35 < 40, so it stays. A[6] stays as well, since 5 < 40.

Phase 2:

We start with A[7] = {42,30,40,-15,15,35,5}.
We swap the last index, i, with the first element. {5,30,40,-15,15,35,42}
We push_back 5 {5,30,40,-15,15,35,42} -> {30,5,40,-15,15,35,42}-> {30,15,40,-15,5,35,42}.
We push back 30 {30,15,40,-15,5,35,42} -> {40,15,30,-15,5,35,42} -> {40,15,35,-15,5,30,42}.
We now have a correct heap
We swap i - 1 with the first element {30,15,35,-15,5,40,42}
We push_back 30 {30,15,35,-15,5,40,42} -> {35,15,30,-15,5,40,42}
We now have a correct heap.
We swap i - 2 with the first element {5,15,30,-15,35,40,42}
We push_back 5 {5,15,30,-15,35,40,42} -> {15,5,30,-15,35,40,42} -> {15,-15,30,5,35,40,42}
We now have a correct heap
We swap i - 3 {5,-15,30,15,35,40,42}
We push_back 5 {5,-15,30,15,35,40,42} -> {30,-15,5,15,35,40,42}
we now have a correct heap
We swap i - 4 {15,-15,5,30,35,40,42}
We now have a correct heap
We swap i - 5 {5,-15,15,30,35,40,42}
We now have a correct heap
We swap i - 6 {-15,5,15,30,35,40,42}
This finishes the algorithm.

order of runtime complexity:
push up: O(f(n)) = O(log(n))
build_heap: O(f(n)) = O(log(n))
push_down: O(f(n)) = O(log(n))
swap: O(f(n)) = O(log(n))
pick_heap: O(f(n)) = O(log(n))

Operations in a binomial heap are of runtime complexity order O(log(n))
Thus the runtime complexity order of heap sort is O(log(n)) for an array of n elements.
*/

// MuziekDB
struct Length
{
    int minutes;
    int seconds;
};
struct Track
{
    string artist;
    string cd;
    int    year;
    int    track;
    string title;
    string tags;
    Length time;
    string country;
};

vector<Track> vect;
int counter = 0;

// Operators
bool operator<(const Length& a, const Length& b)
{
    if (a.minutes == b.minutes)
    {
        return a.seconds < b.seconds;
    }
    return a.minutes < b.minutes;
}

bool operator==(const Length& a, const Length& b)
{
    return (a.minutes == b.minutes && a.seconds == b.seconds);
}

bool operator<(const Track& a, const Track& b)
{
    counter++;
    if (a.artist < b.artist)
        return true;
    if (a.artist == b.artist && a.cd < b.cd)
        return true;
    if (a.artist == b.artist && a.cd == b.cd && a.year < b.year)
        return true;
    if (a.artist == b.artist && a.cd == b.cd && a.year == b.year && a.track < b.track)
        return true;
    return false;
}

bool operator==(const Track& a, const Track& b)
{
    counter++;
    return (a.artist == b.artist && a.cd == b.cd && a.year == b.year && a.track == b.track);
}

bool operator>(const Track& a, const Track& b)
{
    return b < a ;
}

bool operator<=(const Track& a, const Track& b)
{
    return !(b < a) ;
}

bool operator>=(const Track& a, const Track& b)
{
    return b <= a ;
}

// File input
istream& operator>> (istream& in, Length& length)
{
    // Precondition:
    assert (true) ;
    char colon ;
    in >> length.minutes >> colon >> length.seconds ;
    return in ;
}

ostream& operator<< (ostream& out, const Length length)
{
    out << length.minutes << ':' ;
    if (length.seconds < 10)
        out << '0' ;
    out << length.seconds ;
    return out ;
}

istream& operator>> (istream& infile, Track& track)
{
    string dummy;
    getline(infile,track.artist);       // artist
    getline(infile,track.cd);           // cd
    infile >> track.year ;              // year
    getline(infile, dummy) ;            // verwijder t/m newline
    infile >> track.track ;             // track nr
    getline(infile, dummy) ;            // verwijder t/m newline
    getline(infile,track.title);        // track title
    getline(infile,track.tags);         // track tags
    infile >> track.time ;              // track time
    getline(infile, dummy) ;            // verwijder t/m newline
    getline(infile,track.country);      // country
    getline(infile, dummy) ;            // verwijder t/m newline
    return infile ;
}

ostream& operator<< (ostream& out, const Track track)
{
    out << track.artist << " " << track.cd << " [" << track.track << "] (" << track.time << ")" ;
    return out ;
}

int read_songs(ifstream& infile, vector<Track>& vect)
{
    // Precondition:
    assert(true);
    // Postcondition:
    int trackcount = 0;
    Track buffer;
    while(!infile.eof())
    {
        trackcount = vect.size();
        infile >> buffer;
        vect.push_back(buffer);
    }
    return trackcount;
}

int read_file(string filename)
{
    // Precondition:
    assert(true);
    // Postcondition:
    ifstream songsDBS (filename.c_str());
    if (!songsDBS)
    {
        cout << "Kon '" << filename << "' niet openen." << endl;
        return -1;
    }
    cout << "Lees '" << filename << "' in." << endl;
    int amount = read_songs(songsDBS, vect);
    songsDBS.close();
    return amount;
}

void show_MusicDB (vector<Track>& vect, int songAmmount)
{
    // Precondition:
    assert(vect.size() > 0 && songAmmount > 0);
    // Postcondition:
    for (int i = 0 ; i < songAmmount; i++)
        cout << i+1 << ". " << vect[i] << endl ;
}

bool has_child(int parent, int vectsize)
{
    // Precondition:
    assert(true);
    // Postcondition:
    return parent * 2 < vectsize;
}

void push_up(vector<Track> &vect)
{
    // Precondition:
    assert(vect.size() > 0);
    // Postcondition:
    Track buffer;
    for (int i = 0; i < vect.size(); i++)
    {
        int child = i;
        while (vect[child] > vect[(child - 1) / 2])
        {
            int parent = (child - 1) / 2;
            buffer = vect[parent];
            vect[parent] = vect[child];
            vect[child] = buffer;
            child = parent;
        }
    }
}

void push_down(vector<Track> &vect, int end_of_array)
{
    // Precondition:
    assert(vect.size() > 0);
    // Postcondition:
    Track buffer;
    int parent = 0;
    int child1 = parent * 2 + 1;
    int child2 = parent * 2 + 2;

    while (has_child(parent, end_of_array) &&(vect[parent] < vect[child1] || has_child(parent, end_of_array - 1) &&
            vect[parent] < vect[child2]))
    {
        if (has_child(parent, end_of_array - 1) && vect[child1] > vect[child2] || !has_child(parent, end_of_array - 1))
        {
            if (vect[child1] > vect[parent])
            {
                buffer = vect[parent];
                vect[parent] = vect[child1];
                vect[child1] = buffer;
                parent = child1;
                child1 = parent * 2 + 1;
                child2 = parent * 2 + 2;
            }
        }
        else if (vect[child1] < vect[child2])
        {
            if (vect[child2] > vect[parent])
            {
                buffer = vect[parent];
                vect[parent] = vect[child2];
                vect[child2] = buffer;
                parent = child2;
                child1 = parent * 2 + 1;
                child2 = parent * 2 + 2;
            }
        }
        else
            break;
    }
}

void swap(vector<Track> &vect, int &end_of_array)
{
    // Precondition:
    assert(vect.size() > 0);
    // Postcondition:
    Track buffer;
    buffer = vect[0];
    vect[0] = vect[end_of_array];
    vect[end_of_array] = buffer;
    end_of_array--;
}

void build_heap(vector<Track> &vect)
{
    // Precondition:
    assert(vect.size() > 0);
    // Postcondition:
    push_up(vect);
}

void pick_heap(vector<Track> &vect)
{
    // Precondition:
    assert(vect.size() > 0);
    // Postcondition:
    int end_of_array = vect.size() - 1;
    while (end_of_array > 0)
    {
        swap(vect, end_of_array);
        push_down(vect, end_of_array);
    }
}

void read_file_visualise(vector<Track>& vect){
    // Precondition:
    assert(true);
    // Postcondition:
    ifstream songsDB ("Nummers.txt");
    if (!songsDB)
    {
        cout << "Kon 'Nummers.txt' niet openen." << endl;
    }
    read_songs(songsDB, vect);
}

void visualise_Comparisons(){
    // Precondition:
    assert(true);
    // Postcondition:
    vector<Track> vect;
    int maxSongs = 99;
    int counterOutput = 0;
    while(maxSongs <= 5599){
        read_file_visualise(vect);
        while(vect.size() != maxSongs){
            vect.pop_back();
        }
        build_heap(vect);
        pick_heap(vect);
        while(counter > 100000){
            cout << "*";
            counter -= 100000;
        }
        if(counter > 0)
            cout << ".";
        counterOutput += counter;
        counter = 0;
        maxSongs += 100;
        while(!vect.empty()){
            vect.pop_back();
        }
        cout << endl;
    }
    cout << endl;
    cout << "Volledige bestand gesorteerd." << endl;
    cout << counterOutput << " vergelijkingen gemaakt." << endl;
}

/*
Comparisons with insertion, selection and bubble sort algorithms.
We can clearly see that heap sort is way more efficient than the other three algorithms, just by looking at the amount of comparisons made:

Insertion:          31597885 comparisons.
Selection:          15806253 comparisons.
Bubble:               402228 comparisons.
Heap:                 259931 comparisons.
Improved Insertion:    10891 comparisons.

As shown, it only gets trumped by the improved insertion sort algorithm from last week.
Heap sort is more efficient since it makes less comparisons. It only has to shuffle around values using internal buffers, so it only makes comparisons when it
absolutely has to, instead of with every step.
*/

int main(){
    /*
    Vector test values:
    vect.push_back(1);
    vect.push_back(2);
    vect.push_back(5);
    vect.push_back(8);
    vect.push_back(334);
    vect.push_back(-742);
    vect.push_back(23);
    vect.push_back(84);
    vect.push_back(-68);
    vect.push_back(38);
    */

    int songAmount = read_file("Nummers.txt");
    int choice;
    char visual;
    cout << songAmount << " nummers gevonden." << endl;
    cout << endl;
    cout << "Wil je:" << endl;
    cout << "[1] nummers sorteren?" << endl;
    cout << "[2] aantal vergelijkingen weergeven?" << endl;
    cin >> choice;
    cout << endl;
    if(choice == 1){
        cout << "Wil je de database ook weergeven? [Y]es / [N]o." << endl;
        cin >> visual;
        cout << endl;
        if(visual == 'y' || visual == 'Y'){
            build_heap(vect);
            pick_heap(vect);
            show_MusicDB(vect, songAmount);
            cout << endl;
            cout << "Nummers gesorteerd." << endl;
            cout << counter << " vergelijkingen gemaakt." << endl;
            return 0;
        }
        build_heap(vect);
        pick_heap(vect);
        cout << "Nummers gesorteerd." << endl;
        cout << counter << " vergelijkingen gemaakt." << endl;
        return 0;
    }
    visualise_Comparisons();
    return 0;

    /*
    cout << "Build heap:" << endl;
    build_heap(vect);
    for (int i = 0; i < vect.size(); i++)
    {
        cout << vect[i] << " ";
    }
    cout << endl;
    cout << endl;
    cout << "Pick heap:" << endl;
    pick_heap(vect);
    for (int i = 0; i < vect.size(); i++)
    {
        cout << vect[i] << " ";
    }
    cout << endl;
    show_MusicDB(vect, songAmount);
    cout << endl;
    cout << "Nummers gesorteerd." << endl;
    cout << counter << " vergelijkingen gemaakt." << endl;
    */
}
